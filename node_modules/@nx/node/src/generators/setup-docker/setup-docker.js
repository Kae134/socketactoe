"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupDockerGenerator = exports.updateProjectConfig = void 0;
const devkit_1 = require("@nx/devkit");
const path_1 = require("path");
const utils_1 = require("nx/src/tasks-runner/utils");
const project_graph_1 = require("nx/src/project-graph/project-graph");
function normalizeOptions(tree, setupOptions) {
    return {
        ...setupOptions,
        project: setupOptions.project ?? (0, devkit_1.readNxJson)(tree).defaultProject,
        targetName: setupOptions.targetName ?? 'docker-build',
        buildTarget: setupOptions.buildTarget ?? 'build',
    };
}
function addDocker(tree, options) {
    // Inferred targets are only available in the project graph
    const projectConfig = (0, project_graph_1.readCachedProjectConfiguration)(options.project);
    if (!projectConfig ||
        !projectConfig.targets ||
        !projectConfig.targets[options.buildTarget]) {
        return;
    }
    // Returns an string like {workspaceRoot}/dist/apps/{projectName}
    // Non crystalized projects would return {options.outputPath}
    const tokenizedOutputPath = projectConfig.targets[`${options.buildTarget}`]?.outputs?.[0];
    const maybeBuildOptions = projectConfig.targets[`${options.buildTarget}`]?.options;
    if (tree.exists((0, devkit_1.joinPathFragments)(projectConfig.root, 'DockerFile'))) {
        devkit_1.logger.info(`Skipping setup since a Dockerfile already exists inside ${projectConfig.root}`);
    }
    else if (!tokenizedOutputPath) {
        devkit_1.logger.error(`Skipping setup since the output path for the build target ${options.buildTarget} is not defined.`);
    }
    else {
        const outputPath = (0, utils_1.interpolate)(tokenizedOutputPath, {
            projectName: projectConfig.name,
            projectRoot: projectConfig.root,
            workspaceRoot: '',
            options: maybeBuildOptions || '',
        });
        (0, devkit_1.generateFiles)(tree, (0, path_1.join)(__dirname, './files'), projectConfig.root, {
            tmpl: '',
            app: projectConfig.sourceRoot,
            buildLocation: outputPath,
            project: options.project,
        });
    }
}
function updateProjectConfig(tree, options) {
    let projectConfig = (0, devkit_1.readProjectConfiguration)(tree, options.project);
    projectConfig.targets[`${options.targetName}`] = {
        dependsOn: [`${options.buildTarget}`],
        command: `docker build -f ${(0, devkit_1.joinPathFragments)(projectConfig.root, 'Dockerfile')} . -t ${options.project}`,
    };
    (0, devkit_1.updateProjectConfiguration)(tree, options.project, projectConfig);
}
exports.updateProjectConfig = updateProjectConfig;
async function setupDockerGenerator(tree, setupOptions) {
    const tasks = [];
    const options = normalizeOptions(tree, setupOptions);
    // Should check if the node project exists
    addDocker(tree, options);
    updateProjectConfig(tree, options);
    if (!options.skipFormat) {
        await (0, devkit_1.formatFiles)(tree);
    }
    return (0, devkit_1.runTasksInSerial)(...tasks);
}
exports.setupDockerGenerator = setupDockerGenerator;
exports.default = setupDockerGenerator;
