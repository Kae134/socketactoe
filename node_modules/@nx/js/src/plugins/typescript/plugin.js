"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNodes = exports.PLUGIN_NAME = exports.createDependencies = void 0;
const devkit_1 = require("@nx/devkit");
const calculate_hash_for_create_nodes_1 = require("@nx/devkit/src/utils/calculate-hash-for-create-nodes");
const get_named_inputs_1 = require("@nx/devkit/src/utils/get-named-inputs");
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
const minimatch_1 = require("minimatch");
// eslint-disable-next-line @typescript-eslint/no-restricted-imports
const lock_file_1 = require("nx/src/plugins/js/lock-file/lock-file");
const cache_directory_1 = require("nx/src/utils/cache-directory");
const ts_config_1 = require("../../utils/typescript/ts-config");
const cachePath = (0, node_path_1.join)(cache_directory_1.projectGraphCacheDirectory, 'tsc.hash');
const targetsCache = readTargetsCache();
function readTargetsCache() {
    return (0, node_fs_1.existsSync)(cachePath) ? (0, devkit_1.readJsonFile)(cachePath) : {};
}
function writeTargetsToCache() {
    const oldCache = readTargetsCache();
    (0, devkit_1.writeJsonFile)(cachePath, {
        ...oldCache,
        ...targetsCache,
    });
}
const createDependencies = () => {
    writeTargetsToCache();
    return [];
};
exports.createDependencies = createDependencies;
exports.PLUGIN_NAME = '@nx/js/typescript';
exports.createNodes = [
    '**/tsconfig*.json',
    (configFilePath, options, context) => {
        const pluginOptions = normalizePluginOptions(options);
        const projectRoot = (0, node_path_1.dirname)(configFilePath);
        const fullConfigPath = (0, devkit_1.joinPathFragments)(context.workspaceRoot, configFilePath);
        // Do not create a project if package.json and project.json isn't there.
        const siblingFiles = (0, node_fs_1.readdirSync)((0, node_path_1.join)(context.workspaceRoot, projectRoot));
        if (!siblingFiles.includes('package.json') &&
            !siblingFiles.includes('project.json')) {
            return {};
        }
        // Do not create a project if it's not a tsconfig.json and there is no tsconfig.json in the same directory
        if ((0, node_path_1.basename)(configFilePath) !== 'tsconfig.json' &&
            !siblingFiles.includes('tsconfig.json')) {
            return {};
        }
        const nodeHash = (0, calculate_hash_for_create_nodes_1.calculateHashForCreateNodes)(projectRoot, pluginOptions, context, [(0, lock_file_1.getLockFileName)((0, devkit_1.detectPackageManager)(context.workspaceRoot))]);
        // The hash is calculated at the node/project level, so we add the config file path to avoid conflicts when caching
        const cacheKey = `${nodeHash}_${configFilePath}`;
        targetsCache[cacheKey] ??= buildTscTargets(fullConfigPath, projectRoot, pluginOptions, context);
        return {
            projects: {
                [projectRoot]: {
                    projectType: 'library',
                    targets: targetsCache[cacheKey],
                },
            },
        };
    },
];
function buildTscTargets(configFilePath, projectRoot, options, context) {
    const targets = {};
    const namedInputs = (0, get_named_inputs_1.getNamedInputs)(projectRoot, context);
    const tsConfig = readCachedTsConfig(configFilePath);
    // TODO: check whether we want to always run with --pretty --verbose, it makes replacing scripts harder
    // `--verbose` conflicts with `tsc -b --clean`, might be another reason for not using it, it would
    // prevent users from running the task with `--clean` flag.
    // Should we consider creating a different optional target for `--clean`?
    // Should we consider having a plugin option to disable `--pretty` and `--verbose`?
    let internalProjectReferences;
    // Typecheck target
    if ((0, node_path_1.basename)(configFilePath) === 'tsconfig.json' && options.typecheck) {
        internalProjectReferences = resolveInternalProjectReferences(configFilePath, tsConfig);
        const targetName = options.typecheck.targetName;
        if (!targets[targetName]) {
            let command = `tsc --build --emitDeclarationOnly --pretty --verbose`;
            if (tsConfig.options.noEmit ||
                Object.values(internalProjectReferences).some((ref) => ref.options.noEmit)) {
                // `--emitDeclarationOnly` and `--noEmit` are mutually exclusive, so
                // we remove `--emitDeclarationOnly` if `--noEmit` is set.
                command = `tsc --build --pretty --verbose`;
            }
            targets[targetName] = {
                dependsOn: [`^${targetName}`],
                command,
                options: { cwd: projectRoot },
                cache: true,
                inputs: getInputs(namedInputs, configFilePath, tsConfig, internalProjectReferences, context.workspaceRoot, projectRoot),
                outputs: getOutputs(configFilePath, tsConfig, internalProjectReferences, context.workspaceRoot, projectRoot),
            };
        }
    }
    // Build target
    if (options.build && (0, node_path_1.basename)(configFilePath) === options.build.configName) {
        internalProjectReferences ??= resolveInternalProjectReferences(configFilePath, tsConfig);
        const targetName = options.build.targetName;
        targets[targetName] = {
            dependsOn: [`^${targetName}`],
            command: `tsc --build ${options.build.configName} --pretty --verbose`,
            options: { cwd: projectRoot },
            cache: true,
            inputs: getInputs(namedInputs, configFilePath, tsConfig, internalProjectReferences, context.workspaceRoot, projectRoot),
            outputs: getOutputs(configFilePath, tsConfig, internalProjectReferences, context.workspaceRoot, projectRoot),
        };
    }
    return targets;
}
function getInputs(namedInputs, configFilePath, tsConfig, internalProjectReferences, workspaceRoot, projectRoot) {
    const configFiles = new Set();
    const includePaths = new Set();
    const excludePaths = new Set();
    const extendedConfigFiles = getExtendedConfigFiles(configFilePath, tsConfig);
    extendedConfigFiles.forEach((configPath) => {
        configFiles.add(configPath);
    });
    const projectTsConfigFiles = [
        [configFilePath, tsConfig],
        ...Object.entries(internalProjectReferences),
    ];
    projectTsConfigFiles.forEach(([configPath, config]) => {
        configFiles.add(configPath);
        (config.raw?.include ?? []).forEach((p) => includePaths.add(p));
        if (config.raw?.exclude) {
            /**
             * We need to filter out the exclude paths that are already included in
             * other tsconfig files. If they are not included in other tsconfig files,
             * they still correctly apply to the current file and we should keep them.
             */
            const otherFilesInclude = [];
            projectTsConfigFiles.forEach(([path, c]) => {
                if (path !== configPath) {
                    otherFilesInclude.push(...(c.raw?.include ?? []));
                }
            });
            const normalize = (p) => (p.startsWith('./') ? p.slice(2) : p);
            config.raw.exclude.forEach((excludePath) => {
                if (!otherFilesInclude.some((includePath) => (0, minimatch_1.minimatch)(normalize(includePath), normalize(excludePath)) ||
                    (0, minimatch_1.minimatch)(normalize(excludePath), normalize(includePath)))) {
                    excludePaths.add(excludePath);
                }
            });
        }
    });
    const inputs = [];
    if (includePaths.size) {
        inputs.push(...Array.from(configFiles).map((p) => pathToInputOrOutput(p, workspaceRoot, projectRoot)), ...Array.from(includePaths).map((p) => (0, devkit_1.joinPathFragments)('{projectRoot}', p)));
    }
    else {
        // If we couldn't identify any include paths, we default to the default
        // named inputs.
        inputs.push('production' in namedInputs ? 'production' : 'default');
    }
    if (excludePaths.size) {
        inputs.push(...Array.from(excludePaths).map((p) => `!${(0, devkit_1.joinPathFragments)('{projectRoot}', p)}`));
    }
    if (hasExternalProjectReferences(configFilePath, tsConfig)) {
        // Importing modules from a referenced project will load its output declaration files (d.ts)
        // https://www.typescriptlang.org/docs/handbook/project-references.html#what-is-a-project-reference
        inputs.push({ dependentTasksOutputFiles: '**/*.d.ts' });
    }
    else {
        inputs.push('production' in namedInputs ? '^production' : '^default');
    }
    inputs.push({ externalDependencies: ['typescript'] });
    return inputs;
}
function getOutputs(configFilePath, tsConfig, internalProjectReferences, workspaceRoot, projectRoot) {
    const outputs = new Set();
    // We could have more surgical outputs based on the tsconfig options, but the
    // user could override them through the command line and that wouldn't be
    // reflected in the outputs. So, we just include everything that could be
    // produced by the tsc command.
    [tsConfig, ...Object.values(internalProjectReferences)].forEach((config) => {
        if (config.options.outFile) {
            const outFileName = (0, node_path_1.basename)(config.options.outFile, '.js');
            const outFileDir = (0, node_path_1.dirname)(config.options.outFile);
            outputs.add((0, devkit_1.joinPathFragments)('{workspaceRoot}', (0, node_path_1.relative)(workspaceRoot, config.options.outFile)));
            // outFile is not be used with .cjs, .mjs, .jsx, so the list is simpler
            const outDir = (0, node_path_1.relative)(workspaceRoot, outFileDir);
            outputs.add((0, devkit_1.joinPathFragments)('{workspaceRoot}', outDir, `${outFileName}.js.map`));
            outputs.add((0, devkit_1.joinPathFragments)('{workspaceRoot}', outDir, `${outFileName}.d.ts`));
            outputs.add((0, devkit_1.joinPathFragments)('{workspaceRoot}', outDir, `${outFileName}.d.ts.map`));
            // https://www.typescriptlang.org/tsconfig#tsBuildInfoFile
            outputs.add(tsConfig.options.tsBuildInfoFile
                ? pathToInputOrOutput(tsConfig.options.tsBuildInfoFile, workspaceRoot, projectRoot)
                : (0, devkit_1.joinPathFragments)('{workspaceRoot}', outDir, `${outFileName}.tsbuildinfo`));
        }
        else if (config.options.outDir) {
            outputs.add((0, devkit_1.joinPathFragments)('{workspaceRoot}', (0, node_path_1.relative)(workspaceRoot, config.options.outDir)));
        }
        else if (config.fileNames.length) {
            // tsc produce files in place when no outDir or outFile is set
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.js'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.cjs'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.mjs'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.jsx'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.js.map')); // should also include .cjs and .mjs data
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.jsx.map'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.d.ts'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.d.cts'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.d.mts'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.d.ts.map'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.d.cts.map'));
            outputs.add((0, devkit_1.joinPathFragments)('{projectRoot}', '**/*.d.mts.map'));
            // https://www.typescriptlang.org/tsconfig#tsBuildInfoFile
            const name = (0, node_path_1.basename)(configFilePath, '.json');
            outputs.add(tsConfig.options.tsBuildInfoFile
                ? pathToInputOrOutput(tsConfig.options.tsBuildInfoFile, workspaceRoot, projectRoot)
                : (0, devkit_1.joinPathFragments)('{projectRoot}', `${name}.tsbuildinfo`));
        }
    });
    return Array.from(outputs);
}
function pathToInputOrOutput(path, workspaceRoot, projectRoot) {
    const pathRelativeToProjectRoot = (0, devkit_1.normalizePath)((0, node_path_1.relative)(projectRoot, path));
    if (pathRelativeToProjectRoot.startsWith('..')) {
        return (0, devkit_1.joinPathFragments)('{workspaceRoot}', (0, node_path_1.relative)(workspaceRoot, path));
    }
    return (0, devkit_1.joinPathFragments)('{projectRoot}', pathRelativeToProjectRoot);
}
function getExtendedConfigFiles(tsConfigPath, tsConfig) {
    const extendedConfigFiles = new Set();
    let currentConfigPath = tsConfigPath;
    let currentConfig = tsConfig;
    while (currentConfig.raw?.extends) {
        const extendedConfigPath = (0, node_path_1.join)((0, node_path_1.dirname)(currentConfigPath), currentConfig.raw.extends);
        extendedConfigFiles.add(extendedConfigPath);
        const extendedConfig = readCachedTsConfig(extendedConfigPath);
        currentConfigPath = extendedConfigPath;
        currentConfig = extendedConfig;
    }
    return Array.from(extendedConfigFiles);
}
function resolveInternalProjectReferences(configFilePath, tsConfig, projectReferences = {}) {
    if (!tsConfig.projectReferences?.length) {
        return projectReferences;
    }
    const basePath = getTsConfigBasePath(configFilePath);
    for (const ref of tsConfig.projectReferences) {
        let refConfigPath = ref.path;
        if (projectReferences[refConfigPath]) {
            // Already resolved
            continue;
        }
        if (isExternalProjectReference(refConfigPath, basePath)) {
            continue;
        }
        if (!refConfigPath.endsWith('.json')) {
            refConfigPath = (0, node_path_1.join)(refConfigPath, 'tsconfig.json');
        }
        const refTsConfig = readCachedTsConfig(refConfigPath);
        projectReferences[refConfigPath] = refTsConfig;
        resolveInternalProjectReferences(refConfigPath, refTsConfig, projectReferences);
    }
    return projectReferences;
}
function hasExternalProjectReferences(tsConfigPath, tsConfig, seen = new Set()) {
    if (!tsConfig.projectReferences?.length) {
        return false;
    }
    seen.add(tsConfigPath);
    const basePath = getTsConfigBasePath(tsConfigPath);
    for (const ref of tsConfig.projectReferences) {
        let refConfigPath = ref.path;
        if (seen.has(refConfigPath)) {
            // Already seen
            continue;
        }
        if (isExternalProjectReference(refConfigPath, basePath)) {
            return true;
        }
        if (!refConfigPath.endsWith('.json')) {
            refConfigPath = (0, node_path_1.join)(refConfigPath, 'tsconfig.json');
        }
        const refTsConfig = readCachedTsConfig(refConfigPath);
        const result = hasExternalProjectReferences(refConfigPath, refTsConfig);
        if (result) {
            return true;
        }
    }
    return false;
}
function isExternalProjectReference(refTsConfigPath, basePath) {
    const refBasePath = getTsConfigBasePath(refTsConfigPath);
    // TODO: there could be internal project references in nested dirs (e.g.
    // our storybook generator generates a nested `.storybook/tsconfig.json`),
    // which would be considered an external project reference but it's not.
    // We could instead check if the referenced tsconfig is outside the project
    // root, but that would cause issues with standalone workspaces with nested
    // projects.
    return refBasePath !== basePath;
}
function getTsConfigBasePath(tsConfigPath) {
    return (0, node_fs_1.statSync)(tsConfigPath).isFile() ? (0, node_path_1.dirname)(tsConfigPath) : tsConfigPath;
}
// TODO: we could probably persist this to disk to avoid reading the same
// tsconfig files over multiple runs
const tsConfigCache = new Map();
function readCachedTsConfig(tsConfigPath) {
    const cacheKey = getTsConfigCacheKey(tsConfigPath);
    if (tsConfigCache.has(cacheKey)) {
        return tsConfigCache.get(cacheKey);
    }
    const tsConfig = (0, ts_config_1.readTsConfig)(tsConfigPath);
    tsConfigCache.set(cacheKey, tsConfig);
    return tsConfig;
}
function getTsConfigCacheKey(tsConfigPath) {
    const timestamp = (0, node_fs_1.statSync)(tsConfigPath).mtimeMs;
    return `${tsConfigPath}-${timestamp}`;
}
function normalizePluginOptions(pluginOptions = {}) {
    const defaultTypecheckTargetName = 'typecheck';
    let typecheck = {
        targetName: defaultTypecheckTargetName,
    };
    if (pluginOptions.typecheck === false) {
        typecheck = false;
    }
    else if (pluginOptions.typecheck &&
        typeof pluginOptions.typecheck !== 'boolean') {
        typecheck = {
            targetName: pluginOptions.typecheck.targetName ?? defaultTypecheckTargetName,
        };
    }
    const defaultBuildTargetName = 'build';
    const defaultBuildConfigName = 'tsconfig.lib.json';
    let build = {
        targetName: defaultBuildTargetName,
        configName: defaultBuildConfigName,
    };
    // Build target is not enabled by default
    if (!pluginOptions.build) {
        build = false;
    }
    else if (pluginOptions.build && typeof pluginOptions.build !== 'boolean') {
        build = {
            targetName: pluginOptions.build.targetName ?? defaultBuildTargetName,
            configName: pluginOptions.build.configName ?? defaultBuildConfigName,
        };
    }
    return {
        typecheck,
        build,
    };
}
