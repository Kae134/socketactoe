"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNodes = void 0;
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
const globs_1 = require("nx/src/utils/globs");
const workspace_context_1 = require("nx/src/utils/workspace-context");
const config_file_1 = require("../utils/config-file");
const resolve_eslint_class_1 = require("../utils/resolve-eslint-class");
const semver_1 = require("semver");
const DEFAULT_EXTENSIONS = ['ts', 'tsx', 'js', 'jsx', 'html', 'vue'];
exports.createNodes = [
    (0, globs_1.combineGlobPatterns)([
        ...config_file_1.ESLINT_CONFIG_FILENAMES.map((f) => `**/${f}`),
        config_file_1.baseEsLintConfigFile,
        config_file_1.baseEsLintFlatConfigFile,
    ]),
    async (configFilePath, options, context) => {
        options = normalizeOptions(options);
        const configDir = (0, node_path_1.dirname)(configFilePath);
        // Ensure that configFiles are set, e2e-run fails due to them being undefined in CI (does not occur locally)
        // TODO(JamesHenry): Further troubleshoot this in CI
        context.configFiles = context.configFiles ?? [];
        // Create a Set of all the directories containing eslint configs, and a
        // list of globs to exclude from child projects
        const eslintRoots = new Set();
        const nestedEslintRootPatterns = [];
        for (const configFile of context.configFiles) {
            const eslintRootDir = (0, node_path_1.dirname)(configFile);
            eslintRoots.add(eslintRootDir);
            if (eslintRootDir !== configDir && isSubDir(configDir, eslintRootDir)) {
                nestedEslintRootPatterns.push(`${eslintRootDir}/**/*`);
            }
        }
        const projectFiles = (0, workspace_context_1.globWithWorkspaceContext)(context.workspaceRoot, [
            'project.json',
            'package.json',
            '**/project.json',
            '**/package.json',
        ].map((f) => (0, node_path_1.join)(configDir, f)), nestedEslintRootPatterns.length ? nestedEslintRootPatterns : undefined);
        // dedupe and sort project roots by depth for more efficient traversal
        const dedupedProjectRoots = Array.from(new Set(projectFiles.map((f) => (0, node_path_1.dirname)(f)))).sort((a, b) => (a !== b && isSubDir(a, b) ? -1 : 1));
        const excludePatterns = dedupedProjectRoots.map((root) => `${root}/**/*`);
        const ESLint = await (0, resolve_eslint_class_1.resolveESLintClass)((0, config_file_1.isFlatConfig)(configFilePath));
        const eslintVersion = ESLint.version;
        const childProjectRoots = new Set();
        await Promise.all(dedupedProjectRoots.map(async (childProjectRoot, index) => {
            // anything after is either a nested project or a sibling project, can be excluded
            const nestedProjectRootPatterns = excludePatterns.slice(index + 1);
            // Ignore project roots where the project does not contain any lintable files
            const lintableFiles = (0, workspace_context_1.globWithWorkspaceContext)(context.workspaceRoot, [(0, node_path_1.join)(childProjectRoot, `**/*.{${options.extensions.join(',')}}`)], 
            // exclude nested eslint roots and nested project roots
            [...nestedEslintRootPatterns, ...nestedProjectRootPatterns]);
            const eslint = new ESLint({
                cwd: (0, node_path_1.join)(context.workspaceRoot, childProjectRoot),
            });
            for (const file of lintableFiles) {
                if (!(await eslint.isPathIgnored((0, node_path_1.join)(context.workspaceRoot, file)))) {
                    childProjectRoots.add(childProjectRoot);
                    break;
                }
            }
        }));
        const uniqueChildProjectRoots = Array.from(childProjectRoots);
        return {
            projects: getProjectsUsingESLintConfig(configFilePath, uniqueChildProjectRoots, eslintVersion, options, context),
        };
    },
];
function getProjectsUsingESLintConfig(configFilePath, childProjectRoots, eslintVersion, options, context) {
    const projects = {};
    const rootEslintConfig = [
        config_file_1.baseEsLintConfigFile,
        config_file_1.baseEsLintFlatConfigFile,
        ...config_file_1.ESLINT_CONFIG_FILENAMES,
    ].find((f) => (0, node_fs_1.existsSync)((0, node_path_1.join)(context.workspaceRoot, f)));
    // Add a lint target for each child project without an eslint config, with the root level config as an input
    for (const projectRoot of childProjectRoots) {
        // If there's no src folder, it's not a standalone project, do not add the target at all
        const isStandaloneWorkspace = projectRoot === '.' &&
            (0, node_fs_1.existsSync)((0, node_path_1.join)(context.workspaceRoot, projectRoot, 'src')) &&
            (0, node_fs_1.existsSync)((0, node_path_1.join)(context.workspaceRoot, projectRoot, 'package.json'));
        if (projectRoot === '.' && !isStandaloneWorkspace) {
            continue;
        }
        const eslintConfigs = [configFilePath];
        if (rootEslintConfig && !eslintConfigs.includes(rootEslintConfig)) {
            eslintConfigs.unshift(rootEslintConfig);
        }
        projects[projectRoot] = {
            targets: buildEslintTargets(eslintConfigs, eslintVersion, projectRoot, context.workspaceRoot, options, isStandaloneWorkspace),
        };
    }
    return projects;
}
function buildEslintTargets(eslintConfigs, eslintVersion, projectRoot, workspaceRoot, options, isStandaloneWorkspace = false) {
    const isRootProject = projectRoot === '.';
    const targets = {};
    const targetConfig = {
        command: `eslint ${isRootProject && isStandaloneWorkspace ? './src' : '.'}`,
        cache: true,
        options: {
            cwd: projectRoot,
        },
        inputs: [
            'default',
            // Certain lint rules can be impacted by changes to dependencies
            '^default',
            ...eslintConfigs.map((config) => `{workspaceRoot}/${config}`.replace(`{workspaceRoot}/${projectRoot}`, isRootProject ? '{projectRoot}/' : '{projectRoot}')),
            ...((0, node_fs_1.existsSync)((0, node_path_1.join)(workspaceRoot, projectRoot, '.eslintignore'))
                ? ['{projectRoot}/.eslintignore']
                : []),
            '{workspaceRoot}/tools/eslint-rules/**/*',
            { externalDependencies: ['eslint'] },
        ],
        outputs: ['{options.outputFile}'],
    };
    // Always set the environment variable to ensure that the ESLint CLI can run on eslint v8 and v9
    const useFlatConfig = eslintConfigs.some((config) => (0, config_file_1.isFlatConfig)(config));
    // Flat config is default for 9.0.0+
    const defaultSetting = (0, semver_1.gte)(eslintVersion, '9.0.0');
    if (useFlatConfig !== defaultSetting) {
        targetConfig.options.env = {
            ESLINT_USE_FLAT_CONFIG: useFlatConfig ? 'true' : 'false',
        };
    }
    targets[options.targetName] = targetConfig;
    return targets;
}
function normalizeOptions(options) {
    options ??= {};
    options.targetName ??= 'lint';
    // Normalize user input for extensions (strip leading . characters)
    if (Array.isArray(options.extensions)) {
        options.extensions = options.extensions.map((f) => f.replace(/^\.+/, ''));
    }
    else {
        options.extensions = DEFAULT_EXTENSIONS;
    }
    return options;
}
/**
 * Determines if `child` is a subdirectory of `parent`. This is a simplified
 * version that takes into account that paths are always relative to the
 * workspace root.
 */
function isSubDir(parent, child) {
    if (parent === '.') {
        return true;
    }
    parent = (0, node_path_1.normalize)(parent);
    child = (0, node_path_1.normalize)(child);
    if (!parent.endsWith(node_path_1.sep)) {
        parent += node_path_1.sep;
    }
    return child.startsWith(parent);
}
