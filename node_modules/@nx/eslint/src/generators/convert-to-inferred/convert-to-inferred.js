"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertToInferred = void 0;
const devkit_1 = require("@nx/devkit");
const plugin_1 = require("../../plugins/plugin");
const executor_to_plugin_migrator_1 = require("@nx/devkit/src/generators/plugin-migrations/executor-to-plugin-migrator");
const target_options_map_1 = require("./lib/target-options-map");
const utils_1 = require("nx/src/tasks-runner/utils");
async function convertToInferred(tree, options) {
    const projectGraph = await (0, devkit_1.createProjectGraphAsync)();
    const migratedProjectsModern = await (0, executor_to_plugin_migrator_1.migrateExecutorToPlugin)(tree, projectGraph, '@nx/eslint:lint', '@nx/eslint/plugin', (targetName) => ({ targetName }), postTargetTransformer, plugin_1.createNodes, options.project);
    const migratedProjectsLegacy = await (0, executor_to_plugin_migrator_1.migrateExecutorToPlugin)(tree, projectGraph, '@nrwl/linter:eslint', '@nx/eslint/plugin', (targetName) => ({ targetName }), postTargetTransformer, plugin_1.createNodes, options.project);
    const migratedProjects = migratedProjectsModern.size + migratedProjectsLegacy.size;
    if (migratedProjects === 0) {
        throw new Error('Could not find any targets to migrate.');
    }
    if (!options.skipFormat) {
        await (0, devkit_1.formatFiles)(tree);
    }
}
exports.convertToInferred = convertToInferred;
function postTargetTransformer(target, tree, projectDetails) {
    if (target.inputs) {
        target.inputs = target.inputs.filter((input) => typeof input === 'string' &&
            ![
                'default',
                '{workspaceRoot}/.eslintrc.json',
                '{workspaceRoot}/.eslintignore',
                '{workspaceRoot}/eslint.config.js',
            ].includes(input));
        if (target.inputs.length === 0) {
            delete target.inputs;
        }
    }
    if (target.options) {
        if ('eslintConfig' in target.options) {
            delete target.options.eslintConfig;
        }
        if ('force' in target.options) {
            delete target.options.force;
        }
        if ('silent' in target.options) {
            delete target.options.silent;
        }
        if ('hasTypeAwareRules' in target.options) {
            delete target.options.hasTypeAwareRules;
        }
        if ('errorOnUnmatchedPattern' in target.options) {
            if (!target.options.errorOnUnmatchedPattern) {
                target.options['no-error-on-unmatched-pattern'] = true;
            }
            delete target.options.errorOnUnmatchedPattern;
        }
        if ('outputFile' in target.options) {
            target.outputs ??= [];
            target.outputs.push(target.options.outputFile);
        }
        for (const key in target_options_map_1.targetOptionsToCliMap) {
            if (target.options[key]) {
                target.options[target_options_map_1.targetOptionsToCliMap[key]] = target.options[key];
                delete target.options[key];
            }
        }
        if ('lintFilePatterns' in target.options) {
            const normalizedLintFilePatterns = target.options.lintFilePatterns.map((pattern) => {
                return (0, utils_1.interpolate)(pattern, {
                    workspaceRoot: '',
                    projectRoot: projectDetails.root,
                    projectName: projectDetails.projectName,
                });
            });
            target.options.args = normalizedLintFilePatterns.map((pattern) => pattern.startsWith(projectDetails.root)
                ? pattern.replace(new RegExp(`^${projectDetails.root}/`), './')
                : pattern);
            delete target.options.lintFilePatterns;
        }
    }
    return target;
}
exports.default = convertToInferred;
