"use strict";
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    createDependencies: function() {
        return createDependencies;
    },
    createNodes: function() {
        return createNodes;
    }
});
const _extends = require("@swc/helpers/_/_extends");
const _devkit = require("@nx/devkit");
const _path = require("path");
const _getnamedinputs = require("@nx/devkit/src/utils/get-named-inputs");
const _fs = require("fs");
const _calculatehashforcreatenodes = require("@nx/devkit/src/utils/calculate-hash-for-create-nodes");
const _cachedirectory = require("nx/src/utils/cache-directory");
const _js = require("@nx/js");
const _executorutils = require("../utils/executor-utils");
const cachePath = (0, _path.join)(_cachedirectory.projectGraphCacheDirectory, 'vite.hash');
const targetsCache = readTargetsCache();
function readTargetsCache() {
    return (0, _fs.existsSync)(cachePath) ? (0, _devkit.readJsonFile)(cachePath) : {};
}
function writeTargetsToCache() {
    const oldCache = readTargetsCache();
    (0, _devkit.writeJsonFile)(cachePath, _extends._({}, oldCache, targetsCache));
}
const createDependencies = ()=>{
    writeTargetsToCache();
    return [];
};
const createNodes = [
    '**/{vite,vitest}.config.{js,ts,mjs,mts,cjs,cts}',
    async (configFilePath, options, context)=>{
        var _targetsCache, _hash;
        const projectRoot = (0, _path.dirname)(configFilePath);
        // Do not create a project if package.json and project.json isn't there.
        const siblingFiles = (0, _fs.readdirSync)((0, _path.join)(context.workspaceRoot, projectRoot));
        if (!siblingFiles.includes('package.json') && !siblingFiles.includes('project.json')) {
            return {};
        }
        options = normalizeOptions(options);
        // We do not want to alter how the hash is calculated, so appending the config file path to the hash
        // to prevent vite/vitest files overwriting the target cache created by the other
        const hash = (0, _calculatehashforcreatenodes.calculateHashForCreateNodes)(projectRoot, options, context, [
            (0, _js.getLockFileName)((0, _devkit.detectPackageManager)(context.workspaceRoot))
        ]) + configFilePath;
        var _;
        (_ = (_targetsCache = targetsCache)[_hash = hash]) != null ? _ : _targetsCache[_hash] = await buildViteTargets(configFilePath, projectRoot, options, context);
        return {
            projects: {
                [projectRoot]: {
                    root: projectRoot,
                    targets: targetsCache[hash]
                }
            }
        };
    }
];
async function buildViteTargets(configFilePath, projectRoot, options, context) {
    const absoluteConfigFilePath = (0, _devkit.joinPathFragments)(context.workspaceRoot, configFilePath);
    // Workaround for the `build$3 is not a function` error that we sometimes see in agents.
    // This should be removed later once we address the issue properly
    try {
        const importEsbuild = ()=>new Function('return import("esbuild")')();
        await importEsbuild();
    } catch (e) {
    // do nothing
    }
    const { resolveConfig } = await (0, _executorutils.loadViteDynamicImport)();
    const viteConfig = await resolveConfig({
        configFile: absoluteConfigFilePath,
        mode: 'development'
    }, 'build');
    const { buildOutputs, testOutputs, hasTest, isBuildable } = getOutputs(viteConfig, projectRoot);
    const namedInputs = (0, _getnamedinputs.getNamedInputs)(projectRoot, context);
    const targets = {};
    // If file is not vitest.config and buildable, create targets for build, serve, preview and serve-static
    const hasRemixPlugin = viteConfig.plugins && viteConfig.plugins.some((p)=>p.name === 'remix');
    if (!configFilePath.includes('vitest.config') && !hasRemixPlugin && isBuildable) {
        targets[options.buildTargetName] = await buildTarget(options.buildTargetName, namedInputs, buildOutputs, projectRoot);
        targets[options.serveTargetName] = serveTarget(projectRoot);
        targets[options.previewTargetName] = previewTarget(projectRoot);
        targets[options.serveStaticTargetName] = serveStaticTarget(options);
    }
    // if file is vitest.config or vite.config has definition for test, create target for test
    if (configFilePath.includes('vitest.config') || hasTest) {
        targets[options.testTargetName] = await testTarget(namedInputs, testOutputs, projectRoot);
    }
    return targets;
}
async function buildTarget(buildTargetName, namedInputs, outputs, projectRoot) {
    return {
        command: `vite build`,
        options: {
            cwd: (0, _devkit.joinPathFragments)(projectRoot)
        },
        cache: true,
        dependsOn: [
            `^${buildTargetName}`
        ],
        inputs: [
            ...'production' in namedInputs ? [
                'production',
                '^production'
            ] : [
                'default',
                '^default'
            ],
            {
                externalDependencies: [
                    'vite'
                ]
            }
        ],
        outputs
    };
}
function serveTarget(projectRoot) {
    const targetConfig = {
        command: `vite serve`,
        options: {
            cwd: (0, _devkit.joinPathFragments)(projectRoot)
        }
    };
    return targetConfig;
}
function previewTarget(projectRoot) {
    const targetConfig = {
        command: `vite preview`,
        options: {
            cwd: (0, _devkit.joinPathFragments)(projectRoot)
        }
    };
    return targetConfig;
}
async function testTarget(namedInputs, outputs, projectRoot) {
    return {
        command: `vitest`,
        options: {
            cwd: (0, _devkit.joinPathFragments)(projectRoot)
        },
        cache: true,
        inputs: [
            ...'production' in namedInputs ? [
                'default',
                '^production'
            ] : [
                'default',
                '^default'
            ],
            {
                externalDependencies: [
                    'vitest'
                ]
            },
            {
                env: 'CI'
            }
        ],
        outputs
    };
}
function serveStaticTarget(options) {
    const targetConfig = {
        executor: '@nx/web:file-server',
        options: {
            buildTarget: `${options.buildTargetName}`,
            spa: true
        }
    };
    return targetConfig;
}
function getOutputs(viteConfig, projectRoot) {
    var _build_rollupOptions, _test_coverage;
    const { build, test } = viteConfig;
    const buildOutputPath = normalizeOutputPath(build == null ? void 0 : build.outDir, projectRoot, 'dist');
    const isBuildable = (build == null ? void 0 : build.lib) || (build == null ? void 0 : (_build_rollupOptions = build.rollupOptions) == null ? void 0 : _build_rollupOptions.inputs) || (0, _fs.existsSync)((0, _path.join)(_devkit.workspaceRoot, projectRoot, 'index.html'));
    const reportsDirectoryPath = normalizeOutputPath(test == null ? void 0 : (_test_coverage = test.coverage) == null ? void 0 : _test_coverage.reportsDirectory, projectRoot, 'coverage');
    return {
        buildOutputs: [
            buildOutputPath
        ],
        testOutputs: [
            reportsDirectoryPath
        ],
        hasTest: !!test,
        isBuildable
    };
}
function normalizeOutputPath(outputPath, projectRoot, path) {
    if (!outputPath) {
        if (projectRoot === '.') {
            return `{projectRoot}/${path}`;
        } else {
            return `{workspaceRoot}/${path}/{projectRoot}`;
        }
    } else {
        if ((0, _path.isAbsolute)(outputPath)) {
            return `{workspaceRoot}/${(0, _path.relative)(_devkit.workspaceRoot, outputPath)}`;
        } else {
            if (outputPath.startsWith('..')) {
                return (0, _path.join)('{workspaceRoot}', (0, _path.join)(projectRoot, outputPath));
            } else {
                return (0, _path.join)('{projectRoot}', outputPath);
            }
        }
    }
}
function normalizeOptions(options) {
    var _options, _options1, _options2, _options3, _options4;
    options != null ? options : options = {};
    var _buildTargetName;
    (_buildTargetName = (_options = options).buildTargetName) != null ? _buildTargetName : _options.buildTargetName = 'build';
    var _serveTargetName;
    (_serveTargetName = (_options1 = options).serveTargetName) != null ? _serveTargetName : _options1.serveTargetName = 'serve';
    var _previewTargetName;
    (_previewTargetName = (_options2 = options).previewTargetName) != null ? _previewTargetName : _options2.previewTargetName = 'preview';
    var _testTargetName;
    (_testTargetName = (_options3 = options).testTargetName) != null ? _testTargetName : _options3.testTargetName = 'test';
    var _serveStaticTargetName;
    (_serveStaticTargetName = (_options4 = options).serveStaticTargetName) != null ? _serveStaticTargetName : _options4.serveStaticTargetName = 'serve-static';
    return options;
}

//# sourceMappingURL=plugin.js.map