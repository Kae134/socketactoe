"use strict";
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    getBuildExtraArgs: function() {
        return getBuildExtraArgs;
    },
    viteBuildExecutor: function() {
        return viteBuildExecutor;
    }
});
const _extends = require("@swc/helpers/_/_extends");
const _devkit = require("@nx/devkit");
const _optionsutils = require("../../utils/options-utils");
const _js = require("@nx/js");
const _fs = require("fs");
const _path = require("path");
const _asynciterable = require("@nx/devkit/src/utils/async-iterable");
const _executorutils = require("../../utils/executor-utils");
async function* viteBuildExecutor(options, context) {
    var _resolved_config_build, _resolved_config;
    process.env.VITE_CJS_IGNORE_WARNING = 'true';
    // Allows ESM to be required in CJS modules. Vite will be published as ESM in the future.
    const { mergeConfig, build, loadConfigFromFile } = await (0, _executorutils.loadViteDynamicImport)();
    const projectRoot = context.projectsConfigurations.projects[context.projectName].root;
    (0, _executorutils.createBuildableTsConfig)(projectRoot, options, context);
    const viteConfigPath = (0, _optionsutils.normalizeViteConfigFilePath)(context.root, projectRoot, options.configFile);
    const root = projectRoot === '.' ? process.cwd() : (0, _path.relative)(context.cwd, (0, _devkit.joinPathFragments)(context.root, projectRoot));
    const { buildOptions, otherOptions } = await getBuildExtraArgs(options);
    var _otherOptions_mode;
    const resolved = await loadConfigFromFile({
        mode: (_otherOptions_mode = otherOptions == null ? void 0 : otherOptions.mode) != null ? _otherOptions_mode : 'production',
        command: 'build'
    }, viteConfigPath);
    var _joinPathFragments;
    const outDir = (_joinPathFragments = (0, _devkit.joinPathFragments)((0, _devkit.offsetFromRoot)(projectRoot), options.outputPath)) != null ? _joinPathFragments : resolved == null ? void 0 : (_resolved_config = resolved.config) == null ? void 0 : (_resolved_config_build = _resolved_config.build) == null ? void 0 : _resolved_config_build.outDir;
    var _resolved_config_root;
    const buildConfig = mergeConfig({
        // This should not be needed as it's going to be set in vite.config.ts
        // but leaving it here in case someone did not migrate correctly
        root: (_resolved_config_root = resolved.config.root) != null ? _resolved_config_root : root,
        configFile: viteConfigPath
    }, _extends._({
        build: _extends._({
            outDir
        }, buildOptions)
    }, otherOptions));
    if (!options.skipTypeCheck) {
        var _options_tsConfig;
        await (0, _executorutils.validateTypes)({
            workspaceRoot: context.root,
            projectRoot: projectRoot,
            tsconfig: (_options_tsConfig = options.tsConfig) != null ? _options_tsConfig : (0, _optionsutils.getProjectTsConfigPath)(projectRoot)
        });
    }
    const watcherOrOutput = await build(buildConfig);
    const libraryPackageJson = (0, _path.resolve)(projectRoot, 'package.json');
    const rootPackageJson = (0, _path.resolve)(context.root, 'package.json');
    // Here, we want the outdir relative to the workspace root.
    // So, we calculate the relative path from the workspace root to the outdir.
    const outDirRelativeToWorkspaceRoot = outDir.replaceAll('../', '');
    const distPackageJson = (0, _path.resolve)(outDirRelativeToWorkspaceRoot, 'package.json');
    // Generate a package.json if option has been set.
    if (options.generatePackageJson) {
        if (context.projectGraph.nodes[context.projectName].type !== 'app') {
            _devkit.logger.warn((0, _devkit.stripIndents)`The project ${context.projectName} is using the 'generatePackageJson' option which is deprecated for library projects. It should only be used for applications.
        For libraries, configure the project to use the '@nx/dependency-checks' ESLint rule instead (https://nx.dev/nx-api/eslint-plugin/documents/dependency-checks).`);
        }
        const builtPackageJson = (0, _js.createPackageJson)(context.projectName, context.projectGraph, {
            target: context.targetName,
            root: context.root,
            isProduction: !options.includeDevDependenciesInPackageJson
        });
        builtPackageJson.type = 'module';
        (0, _devkit.writeJsonFile)(`${outDirRelativeToWorkspaceRoot}/package.json`, builtPackageJson);
        const packageManager = (0, _devkit.detectPackageManager)(context.root);
        const lockFile = (0, _js.createLockFile)(builtPackageJson, context.projectGraph, packageManager);
        (0, _fs.writeFileSync)(`${outDirRelativeToWorkspaceRoot}/${(0, _js.getLockFileName)(packageManager)}`, lockFile, {
            encoding: 'utf-8'
        });
    } else if (options.generatePackageJson !== false && !(0, _fs.existsSync)(distPackageJson) && (0, _fs.existsSync)(libraryPackageJson) && rootPackageJson !== libraryPackageJson) {
        await (0, _js.copyAssets)({
            outputPath: outDirRelativeToWorkspaceRoot,
            assets: [
                {
                    input: projectRoot,
                    output: '.',
                    glob: 'package.json'
                }
            ]
        }, context);
    }
    if ('on' in watcherOrOutput) {
        const iterable = (0, _asynciterable.createAsyncIterable)(({ next })=>{
            let success = true;
            watcherOrOutput.on('event', (event)=>{
                if (event.code === 'START') {
                    success = true;
                } else if (event.code === 'ERROR') {
                    success = false;
                } else if (event.code === 'END') {
                    next({
                        success
                    });
                }
                // result must be closed when present.
                // see https://rollupjs.org/guide/en/#rollupwatch
                if ('result' in event && event.result) {
                    event.result.close();
                }
            });
        });
        yield* iterable;
    } else {
        var _watcherOrOutput_, _output_;
        const output = (watcherOrOutput == null ? void 0 : watcherOrOutput['output']) || (watcherOrOutput == null ? void 0 : (_watcherOrOutput_ = watcherOrOutput[0]) == null ? void 0 : _watcherOrOutput_.output);
        const fileName = (output == null ? void 0 : (_output_ = output[0]) == null ? void 0 : _output_.fileName) || 'main.cjs';
        const outfile = (0, _path.resolve)(outDirRelativeToWorkspaceRoot, fileName);
        yield {
            success: true,
            outfile
        };
    }
}
async function getBuildExtraArgs(options) {
    // support passing extra args to vite cli
    const schema = await Promise.resolve().then(()=>require("./schema.json"));
    const extraArgs = {};
    for (const key of Object.keys(options)){
        if (!schema.properties[key]) {
            extraArgs[key] = options[key];
        }
    }
    const buildOptions = {};
    const buildSchemaKeys = [
        'target',
        'polyfillModulePreload',
        'modulePreload',
        'outDir',
        'assetsDir',
        'assetsInlineLimit',
        'cssCodeSplit',
        'cssTarget',
        'cssMinify',
        'sourcemap',
        'minify',
        'terserOptions',
        'rollupOptions',
        'commonjsOptions',
        'dynamicImportVarsOptions',
        'write',
        'emptyOutDir',
        'copyPublicDir',
        'manifest',
        'lib',
        'ssr',
        'ssrManifest',
        'ssrEmitAssets',
        'reportCompressedSize',
        'chunkSizeWarningLimit',
        'watch'
    ];
    const otherOptions = {};
    for (const key of Object.keys(extraArgs)){
        if (buildSchemaKeys.includes(key)) {
            buildOptions[key] = extraArgs[key];
        } else {
            otherOptions[key] = extraArgs[key];
        }
    }
    var _options_watch;
    buildOptions['watch'] = (_options_watch = options.watch) != null ? _options_watch : undefined;
    return {
        buildOptions,
        otherOptions
    };
}
const _default = viteBuildExecutor;

//# sourceMappingURL=build.impl.js.map