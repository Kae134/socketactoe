"use strict";
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    viteConfigurationGenerator: function() {
        return viteConfigurationGenerator;
    },
    viteConfigurationGeneratorInternal: function() {
        return viteConfigurationGeneratorInternal;
    }
});
const _extends = require("@swc/helpers/_/_extends");
const _devkit = require("@nx/devkit");
const _js = require("@nx/js");
const _generatorutils = require("../../utils/generator-utils");
const _init = require("../init/init");
const _vitestgenerator = require("../vitest/vitest-generator");
const _ensuredependencies = require("../../utils/ensure-dependencies");
const _convertnonvite = require("./lib/convert-non-vite");
function viteConfigurationGenerator(host, schema) {
    return viteConfigurationGeneratorInternal(host, _extends._({
        addPlugin: false
    }, schema));
}
async function viteConfigurationGeneratorInternal(tree, schema) {
    var _nxJson_plugins;
    var _schema, // Setting default to jsdom since it is the most common use case (React, Web).
    // The @nx/js:lib generator specifically sets this to node to be more generic.
    _schema1, _schema2;
    const tasks = [];
    const projectConfig = (0, _devkit.readProjectConfiguration)(tree, schema.project);
    const { targets, root: projectRoot } = projectConfig;
    var _projectConfig_projectType;
    const projectType = (_projectConfig_projectType = projectConfig.projectType) != null ? _projectConfig_projectType : 'library';
    var _includeLib;
    (_includeLib = (_schema = schema).includeLib) != null ? _includeLib : _schema.includeLib = projectType === 'library';
    var _testEnvironment;
    (_testEnvironment = (_schema1 = schema).testEnvironment) != null ? _testEnvironment : _schema1.testEnvironment = 'jsdom';
    /**
   * This is for when we are converting an existing project
   * to use the vite executors.
   */ let projectAlreadyHasViteTargets = {};
    if (!schema.newProject) {
        await (0, _convertnonvite.convertNonVite)(tree, schema, projectRoot, projectType, targets);
    }
    const jsInitTask = await (0, _js.initGenerator)(tree, _extends._({}, schema, {
        skipFormat: true,
        tsConfigName: projectRoot === '.' ? 'tsconfig.json' : 'tsconfig.base.json'
    }));
    tasks.push(jsInitTask);
    const initTask = await (0, _init.default)(tree, _extends._({}, schema, {
        skipFormat: true
    }));
    tasks.push(initTask);
    tasks.push((0, _ensuredependencies.ensureDependencies)(tree, schema));
    const nxJson = (0, _devkit.readNxJson)(tree);
    const addPluginDefault = process.env.NX_ADD_PLUGINS !== 'false' && nxJson.useInferencePlugins !== false;
    var _addPlugin;
    (_addPlugin = (_schema2 = schema).addPlugin) != null ? _addPlugin : _schema2.addPlugin = addPluginDefault;
    const hasPlugin = (_nxJson_plugins = nxJson.plugins) == null ? void 0 : _nxJson_plugins.some((p)=>typeof p === 'string' ? p === '@nx/vite/plugin' : p.plugin === '@nx/vite/plugin');
    if (!hasPlugin) {
        if (!projectAlreadyHasViteTargets.build) {
            (0, _generatorutils.addBuildTarget)(tree, schema, 'build');
        }
        if (!schema.includeLib) {
            if (!projectAlreadyHasViteTargets.serve) {
                (0, _generatorutils.addServeTarget)(tree, schema, 'serve');
            }
            if (!projectAlreadyHasViteTargets.preview) {
                (0, _generatorutils.addPreviewTarget)(tree, schema, 'preview');
            }
        }
    }
    if (projectType === 'library') {
        // update tsconfig.lib.json to include vite/client
        (0, _devkit.updateJson)(tree, (0, _devkit.joinPathFragments)(projectRoot, 'tsconfig.lib.json'), (json)=>{
            if (!json.compilerOptions) {
                json.compilerOptions = {};
            }
            if (!json.compilerOptions.types) {
                json.compilerOptions.types = [];
            }
            if (!json.compilerOptions.types.includes('vite/client')) {
                return _extends._({}, json, {
                    compilerOptions: _extends._({}, json.compilerOptions, {
                        types: [
                            ...json.compilerOptions.types,
                            'vite/client'
                        ]
                    })
                });
            }
            return json;
        });
    }
    if (!schema.newProject) {
        // We are converting existing project to use Vite
        if (schema.uiFramework === 'react') {
            (0, _generatorutils.createOrEditViteConfig)(tree, {
                project: schema.project,
                includeLib: schema.includeLib,
                includeVitest: schema.includeVitest,
                inSourceTests: schema.inSourceTests,
                rollupOptionsExternal: [
                    "'react'",
                    "'react-dom'",
                    "'react/jsx-runtime'"
                ],
                imports: [
                    schema.compiler === 'swc' ? `import react from '@vitejs/plugin-react-swc'` : `import react from '@vitejs/plugin-react'`
                ],
                plugins: [
                    'react()'
                ]
            }, false, undefined);
        } else {
            (0, _generatorutils.createOrEditViteConfig)(tree, schema, false, projectAlreadyHasViteTargets);
        }
    }
    if (schema.includeVitest) {
        const vitestTask = await (0, _vitestgenerator.default)(tree, {
            project: schema.project,
            uiFramework: schema.uiFramework,
            inSourceTests: schema.inSourceTests,
            coverageProvider: 'v8',
            skipViteConfig: true,
            testTarget: 'test',
            skipFormat: true,
            addPlugin: schema.addPlugin
        });
        tasks.push(vitestTask);
    }
    if (!schema.skipFormat) {
        await (0, _devkit.formatFiles)(tree);
    }
    return (0, _devkit.runTasksInSerial)(...tasks);
}
const _default = viteConfigurationGenerator;

//# sourceMappingURL=configuration.js.map